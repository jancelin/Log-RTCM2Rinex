# ======================
# Centipede RTCM logger + RINEX (CRX) daily archive
# All times are UTC
# ======================

TZ=UTC

# ----------------------
# Logging verbosity (storage)
# ----------------------
# Global log level used by logger-manager + converter:
#   ERROR | WARN | INFO | DEBUG
#
# NOTE: DEBUG can generate a lot of disk usage (RTKLIB console output).
LOG_LEVEL=INFO

# Per-station monitoring events written to: $PUB_ROOT/logs/events/<MP>.events.log
# Recommended for production: WARN (only outages + abnormal restarts)
STATION_EVENTS_LEVEL=WARN

# Capture per-station RTKLIB console output into: $PUB_ROOT/logs/events/<MP>.log
# This is extremely verbose (status line every ~5s). Default: auto (enabled only in DEBUG).
STATION_CAPTURE_LOG=auto


# Host user id/group id (so files are created with your user ownership on the host)
PUID=1000
PGID=1000

# NTRIP default credentials + caster
NTRIP_HOST=crtk.net
NTRIP_PORT=2101
NTRIP_USER=centipede
NTRIP_PASS=centipede

# Root export (will contain /pub/centipede_30s/...)
PUB_ROOT=/data/pub

# Sorties
RINEX_OUT_ROOT_DAILY=/data/pub/centipede_30s
RINEX_OUT_ROOT_HOURLY=/data/pub/centipede_1s

# Produits
# Les services converter1s/converter30s surchargent ces flags via docker-compose.
RINEX_DAILY_ENABLE=false   # overridden by docker-compose (converter30s)
RINEX_DAILY_INTERVAL_S=30

RINEX_HOURLY_ENABLE=false  # overridden by docker-compose (converter1s)
RINEX_HOURLY_INTERVAL_S=1

# Edge hours (include RTCM files around the target window; convbin time filter (-ts/-te) keeps only desired epochs)
#
# Rôle : collect_rtcm_files_window() inclut les fichiers RTCM des N heures AVANT
# et APRÈS la fenêtre cible, pour capturer les données à cheval sur les rotations
# horaires de str2str. convbin -ts/-te filtre ensuite précisément les epochs voulus.
#
# Impact I/O mesuré (240 stations, fichiers RTCM ~9 Mo/h/station) :
#   edge=1 hourly : 3 fichiers × 9 Mo × 240 stations = 6,5 Go lus/cycle hourly
#                   dont 4,3 Go de redondance (fichiers H-1 et H+1)
#   edge=2 daily  : 5 fichiers × 9 Mo × 240 stations = 10,8 Go lus/cycle daily
#                   dont 7,2 Go de redondance
#
# Recommandations :
#   RINEX_HOURLY_EDGE_HOURS=1 — nécessaire si str2str peut démarrer avec un léger
#     retard (reconnexion réseau) et commencer l'écriture quelques secondes après HH:00.
#     Réduire à 0 uniquement si les fichiers RTCM sont systématiquement complets
#     et que RTCM_SWAP_MARGIN_S=0 (vérifier dans les logs : aucun epoch manquant).
#
#   RINEX_DAILY_EDGE_HOURS=1 — couvre les données à cheval sur minuit UTC
#     (le fichier 23h-00h de la veille peut contenir les dernières minutes du jour J).
#     La valeur par défaut précédente était 2 ; réduite à 1 car le double edge
#     doublait les lectures NFS sans bénéfice documenté avec RTCM_SWAP_MARGIN_S=0.
#     Ne réduire à 0 que si la rotation RTCM est parfaitement synchronisée avec UTC.
RINEX_HOURLY_EDGE_HOURS=1
RINEX_DAILY_EDGE_HOURS=1

# Planning UTC
RINEX_HOURLY_AT_MINUTE=3     # HH:03 UTC (heure précédente)
RINEX_DAILY_AT=00:20         # 00:20 UTC (jour précédent)

TMP_ROOT=/tmp

# ----------------------
# Optimisation I/O : tmpfs (RAM) pour les fichiers temporaires de conversion
# ----------------------
# Les converters utilisent FORCE_TMP_ROOT=/dev/shm/<nom> (défini dans docker-compose.yml)
# ce qui écrase TMP_ROOT ci-dessus pour les containers de conversion.
#
# SHM_MIN_FREE_MB : espace minimum exigé (MiB) sur un candidat tmp avant de l'utiliser.
# Si /dev/shm n'a pas assez de place, le converter bascule automatiquement sur $PUB_ROOT/tmp.
# Calibré pour 1 job individuel (RTCM edge + RNX brut + CRX + marge de sécurité).
#   → converter1s  : ~200 Mo par job × 7 parallel = ~1,4 Go  (shm_size: 2g dans docker-compose)
#   → converter30s : ~350 Mo par job × 7 parallel = ~2,5 Go  (shm_size: 4g dans docker-compose)
# Augmenter si vous observez des WARN "pick_tmp_root: skip /dev/shm" dans les logs.
SHM_MIN_FREE_MB=512

# ----------------------
# str2str logging
# ----------------------
# Rotate RTCM files every N hours (1 = hourly, 24 = daily)
RTCM_ROTATE_HOURS=1
# -f (swap margin, seconds)
RTCM_SWAP_MARGIN_S=0
# str2str network robustness
STR2STR_TIMEOUT_MS=10000
STR2STR_RECONNECT_MS=10000
# RTKLIB trace level (0..5). Trace file stored per station in $PUB_ROOT/logs/traces/<MP>/str2str.trace
#
# VALEUR PAR DÉFAUT CHANGÉE : 2 → 0  (P6 — optimisation I/O production)
#
# Niveaux RTKLIB str2str -t :
#   0 = désactivé — aucun fichier créé (recommandé en production stable)
#   1 = erreurs critiques uniquement
#   2 = connexions/déconnexions, statuts réseau (~1 ligne/5 s par station)
#   3-5 = debug très verbeux (usage développement uniquement)
#
# Impact de STR2STR_TRACE_LEVEL=2 en production (240 stations) :
#   - 240 descripteurs de fichiers ouverts en écriture simultanée sur NFS/disque
#   - ~288 Mo/jour de fichiers .trace (240 stations × ~50 Ko/h × 24 h)
#   - Avec TRACE_RETENTION_DAYS=0 : accumulation sans limite
#   - Contribution estimée au CPU baseline logger : 5-8 % (I/O wait NFS)
#
# La surveillance des stations est assurée par :
#   - Watchdog intégré dans station-logger.sh (STALE_AFTER_SEC)
#   - Fichiers $PUB_ROOT/logs/events/<MP>.events.log
#   - Heartbeat logger-manager
# Le fichier .trace est redondant avec ces mécanismes en production normale.
#
# Pour activer les traces sur UNE station sans redémarrer les autres :
#   Ajouter dans /config/.env : STATION_<MP_KEY>_STR2STR_TRACE_LEVEL=2
#   (ex : STATION_REUN0_STR2STR_TRACE_LEVEL=2)
#   Le script recharge la config à chaque restart de str2str (load_cfg en boucle).
STR2STR_TRACE_LEVEL=0
# RTCM file suffix in filenames
RTCM_SUFFIX=GNSS-1

# "base down" watchdog: log event if no new RTCM file updated for this duration
STALE_CHECK_EVERY_SEC=60
STALE_AFTER_SEC=300

# ----------------------
# RINEX conversion (convbin) + Hatanaka (rnx2crx) + gzip
# ----------------------
RINEX_VERSION=3.04
# RINEX sampling interval in seconds (default 30s)
RINEX_INTERVAL_S=30

# RTKLIB convbin frequency mask passed as: convbin -f <mask>
# IMPORTANT: keep the SAME value for converter services and rinex-backfill scripts,
# otherwise you will get different "SYS / # / OBS TYPES" in the RINEX header.
#
# Typical value used by this project: 4
# If you set 1, output becomes minimal (often L1-only) and many observables disappear.
CONVBIN_FREQ=4

# Conversion UTC window: between start and end (HH:MM), runs every N minutes
CONVERT_WINDOW_START=00:00
CONVERT_WINDOW_END=03:00
CONVERT_EVERY_MIN=30
# Convert yesterday by default (1 = yesterday, 0 = today)
CONVERT_DAYS_BACK=1
# Parallelism when converting multiple stations
CONVERT_PARALLEL=7

# Parallelism for backfill scripts (per hour, across stations)
# If unset, scripts fall back to CONVERT_PARALLEL.
BACKFILL_PARALLEL=7
# Parallelism for daily backfill scripts (per day, across stations)
BACKFILL_DAILY_PARALLEL=7


# Output: generate .crx.gz (Hatanaka compressed)
RINEX_HATANAKA=true
RINEX_GZIP=true

# ----------------------
# Compression parallèle : pigz (multi-thread gzip)
# ----------------------
# pigz produit des fichiers .gz bit-à-bit identiques à gzip (RFC 1952).
# Tous les outils compatibles gzip (gunzip, zcat, nginx, Python gzip…) lisent ces fichiers.
#
# PIGZ_THREADS : nombre de threads de compression par job de conversion.
#   La phase gzip est la DERNIÈRE étape de chaque job (convbin → rnx2crx → gzip).
#   Elle n'est donc pas simultanée entre tous les jobs CONVERT_PARALLEL.
#   Dimensionnement recommandé : floor(CPU_CORES / max_concurrent_gzip_jobs)
#
#   Exemple sur VM 8 cœurs, CONVERT_PARALLEL=7 :
#     Au pic, 1 à 3 jobs compriment simultanément (stagger naturel du pipeline).
#     3 jobs × 2 threads = 6 threads → 2 cœurs libres pour convbin. ✓
#     3 jobs × 3 threads = 9 threads > 8 cœurs → risque de starvation convbin. ✗
#
#   Exemple sur VM 12 cœurs, CONVERT_PARALLEL=10 :
#     Passer à PIGZ_THREADS=3 (3 × 3 = 9 threads max, 3 cœurs libres).
#
#   Référence : M. Adler, "pigz: A Parallel Implementation of gzip"
#     https://zlib.net/pigz/ — rendement ~1.6-1.9x sur fichiers CRX de 30-80 Mo
#
PIGZ_THREADS=2

# GZIP_LEVEL : niveau de compression (1=rapide/gros, 9=lent/petit).
#   Les fichiers CRX (après Hatanaka) sont déjà fortement compressés.
#   Tests empiriques sur données GNSS : écart de taille entre level 4 et level 9 < 2%.
#   Level 6 (défaut gzip/pigz) est le meilleur compromis vitesse/taille.
#   Baisser à 4 ou 5 pour gagner ~15% de vitesse de compression sans perte significative.
GZIP_LEVEL=6
# Remove duplicated epoch blocks in generated RINEX before Hatanaka compression.
#
# Algorithme (P4 — passe unique awk) :
#   Détection ET filtrage des epochs dupliqués en un seul parcours du fichier.
#   Si aucun doublon n'est détecté (cas normal avec RTCM_SWAP_MARGIN_S=0),
#   le fichier original est conservé tel quel (seul un fichier tmp est créé puis supprimé).
#   Si des doublons sont présents : le fichier filtré remplace l'original atomiquement.
#
# Quand des doublons peuvent apparaître :
#   - Si RTCM_SWAP_MARGIN_S > 0 (str2str -f N : chevauchement lors des rotations)
#   - Si des fichiers RTCM de fenêtres adjacentes (edge_hours) se chevauchent
#   - En cas de redémarrage str2str avec relecture du buffer NTRIP
#
# Recommandation :
#   Garder à true tant que RTCM_SWAP_MARGIN_S=0 n'est pas garanti sur toutes les bases.
#   La passe unique a un coût minimal même sans doublon (~40 ms sur tmpfs pour 200 Mo).
RINEX_DEDUP_EPOCHS=true

#web
NGINX_PORT=81


# ----------------------
# Healthchecks (seconds)
# ----------------------
LOGGER_HEALTH_MAX_AGE_SEC=120
CONVERTER_HEALTH_MAX_AGE_SEC=180

# ----------------------
# Retention / cleanup (days)
# 0 = disabled
# ----------------------
# Delete raw RTCM files older than N days (recommended: 3..14)
RTCM_RETENTION_DAYS=0
# Delete str2str traces older than N days
# Recommandé : 7 (avec STR2STR_TRACE_LEVEL=0 la taille est nulle ; utile si quelqu'un
# active temporairement le niveau 2 pour diagnostiquer une station sans oublier de purger)
TRACE_RETENTION_DAYS=7
# Delete event logs older than N days
EVENTS_RETENTION_DAYS=0
# Delete temp files under $PUB_ROOT/tmp older than N days
TMP_RETENTION_DAYS=0
# Daily cleanup time (UTC)
CLEANUP_AT=01:10

# ----------------------
# Optional: querydb (auto-génération hourly de /config/stations.list depuis PostgreSQL)
#
# Activer via Docker Compose profiles :
#   docker compose --profile querydb up -d --build
#
# ---- RINEX header defaults ----
# RENAG-like defaults for serial numbers (REC # and ANT #)
RINEX_REC_NUM_DEFAULT=UNKNOWN
RINEX_ANT_NUM_DEFAULT=UNKNOWN

# Antenna delta defaults (meters) if not provided per station
RINEX_ANT_HGT_DEFAULT=0.0

# ---- querydb (optional) ----
# Enable container with: docker compose --profile querydb up -d --build
# Source view is expected to provide the stations.list columns:
#   mp, rinex_id, x, y, z, rec_type, rec_ver, ant_type, ant_h, ant_e, ant_n
# NOTE: internal spaces in rec_type/rec_ver/ant_type are encoded as '|' in stations.list.
QUERYDB_VIEW=public.station_list_source
QUERYDB_ORDER_BY=mp
QUERYDB_INTERVAL_SECONDS=3600
QUERYDB_OUTPUT=/config/stations.list

# WHERE clause (optional): e.g. "is_active = true AND country = 'FRA'"
# No 'WHERE' keyword here, only the condition.
QUERYDB_WHERE="mp = 'CT02'"

# Connection
QUERYDB_PGHOST=host.docker.internal
QUERYDB_PGPORT=5432
QUERYDB_PGDATABASE=centipede
QUERYDB_PGUSER=centipede_readonly
QUERYDB_PGPASSWORD=CHANGE_ME
QUERYDB_PGSSLMODE=disable

# Antenna deltas defaults (m) if missing in the DB view
QUERYDB_ANT_H_DEFAULT=0.0
QUERYDB_ANT_E_DEFAULT=0.0
QUERYDB_ANT_N_DEFAULT=0.0
